<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[ShareSDK集成分享功能中的一些坑]]></title>
      <url>https://sunnyxibei.github.io/2016/12/09/ShareSDK%E9%9B%86%E6%88%90%E5%88%86%E4%BA%AB%E5%8A%9F%E8%83%BD%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
      <content type="html"><![CDATA[<ul>
<li>每天踩一坑</li>
</ul>
<blockquote>
<p>其实就像用node.js和hexo搭建博客的过程中，集成多说评论等功能一样，SDK的集成本来应该很简单，照着文档写出来，应该就能跑起来。偏偏ShareSDK不是这样，集成过程还是花费了我不少时间，同时吐槽一下ShareSDK的代码规范，太TMD烂了。</p>
</blockquote>
<a id="more"></a>
<h2 id="现在把开发中遇到的问题总结一下："><a href="#现在把开发中遇到的问题总结一下：" class="headerlink" title="现在把开发中遇到的问题总结一下："></a>现在把开发中遇到的问题总结一下：</h2><ul>
<li><p>代码混淆，和很多开源项目一样，关于代码混淆的配置，代码混淆的配置永远都在一个角落里，细心的你一定不要落下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">cn</span>.<span class="title">sharesdk</span>.**&#123;</span>*;&#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sina</span>.**&#123;</span>*;&#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> **.<span class="title">R</span>$* &#123;</span>*;&#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> **.<span class="title">R</span>&#123;</span>*;&#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">mob</span>.**&#123;</span>*;&#125;</span><br><span class="line">-dontwarn com.mob.**</span><br><span class="line">-dontwarn cn.sharesdk.**</span><br><span class="line">-dontwarn **.R$*</span><br></pre></td></tr></table></figure>
</li>
<li><p>微信和微信朋友圈</p>
<p>这里要到微信开放平台，填写应用信息，申请AppId和AppSecret</p>
<p>这里一定要注意了，签名那一栏，填写的是签名的MD5指纹，获取MD5的方式有两种：</p>
<ol>
<li><p>使用微信开放平台上提供的工具，安装到手机上（手机上同时要安装你要申请的App的包，要release签名的），</p>
<p>然后打开工具App，输入你的App的包名，就能获取签名的MD指纹。</p>
</li>
<li><p>使用java的工具keytool，使用命令行查看签名的信息，直接在AndroidStudio的控制台或者自己用cmd打开控制台<br>都可以，具体的命令就不罗列了，自行百度。</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>这里有一个神坑，在微信开放平台上填写签名的MD5的时候，注意两点，第一字母要小写，第二中间不能有冒号”:”，有多少英雄好汉栽倒在这个地方，这儿折腾了我差不多两个小时。</p>
</blockquote>
<ul>
<li>其他的就很简单了，照着ShareSDK的文档开发，一步一步地，你的分享功能就成功了!</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[谁谓河广，一苇航之]]></title>
      <url>https://sunnyxibei.github.io/2016/10/19/%E8%B0%81%E8%B0%93%E6%B2%B3%E5%B9%BF%EF%BC%8C%E4%B8%80%E8%8B%87%E8%88%AA%E4%B9%8B/</url>
      <content type="html"><![CDATA[<p><img src="https://sunnyxibei.github.io/images/head.jpg" class="full-image"></p>
<a id="more"></a>
<p>​    十一假期，不断地观察身边的小孩子，身边的朋友，身边的同事，顿时感觉人生的局限和悲哀。人的思维和习惯，都是来自于自己可以接触到的人，在彼此的不断影响中形成自己的行为。一旦你要突破你的习惯和思考的范围，就会有一种恐慌感，前路漫漫，只能摸着石头过河。然而，好的是，在前行的道路上，或许会遇到同路人，可以共同思考和进步；坏的是，或许会遇到很多TroubleMaker，当然他们并非一定是制造了具体的Trouble，只是他们会诋毁，故意影响你的判断力，混淆是非，把你从前行的道路上拖下水。</p>
<p>​    所以，这个时候，我要更简单地前行。</p>
<p>​    当我踟躇的时候，要不断提醒自己，集中精力，瞄准自己的目标。当初刚刚开始IT生涯的时候，目标还是一些空想，但是时光荏苒，它们逐渐浮出水面。工作，学习，生活，家庭，各种角色，你想要在这个角色里成为怎样的人，尽到怎样的责任，分配怎样的时间，达到怎样的目标，正在一步一步地明晰。</p>
<p>​    工作上，自己就是想往架构师的方向发展，所以要把这个目标分解，在工作中强化自己每个方面的能力。尽量减少抱怨，提高效率。</p>
<p>​    学习上，满足自己的名校情结，同时补足自己的短板，所以在职读研的目标必须实现。</p>
<p>​    生活中，要进一步控制自己的体重，在年底的时候，要线性地减到目标体重。</p>
<p>​    家庭中，要承担起责任和义务。</p>
<p>​    谁谓河广？一苇航之。</p>
<p>​    道路虽长，我们只需一根思想的芦苇，就能一步一步地走向成长的彼岸。</p>
<p>​    一个月以后我将迎接自己孩子的降生。取名“一航”，希望孩子和我一样，在这道路上，更简单地前行。</p>
<p>​    所以，不要轻易地care别人的评论，不要轻易地参与一些毫无意义的争论（不是讨论），要时刻记住自己的目标。前行的道路，很简单，想要什么，就要付出什么。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android7.0源码编译运行指南]]></title>
      <url>https://sunnyxibei.github.io/2016/09/24/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<p>编译环境：Ubuntu 16.04 </p>
<p>镜像文件：清华大学AOSP镜像  Android7.0</p>
<a id="more"></a>
<h2 id="一、源码下载"><a href="#一、源码下载" class="headerlink" title="一、源码下载"></a>一、源码下载</h2><h3 id="1-镜像地址"><a href="#1-镜像地址" class="headerlink" title="1 镜像地址"></a>1 镜像地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">清华大学AOSP(Android Open Source Project)</span><br><span class="line">https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/</span><br></pre></td></tr></table></figure>
<h3 id="2-过程摘录"><a href="#2-过程摘录" class="headerlink" title="2 过程摘录"></a>2 过程摘录</h3><h4 id="下载Repo-工具"><a href="#下载Repo-工具" class="headerlink" title="下载Repo 工具"></a>下载Repo 工具</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/bin</span><br><span class="line">PATH=~/bin:$PATH</span><br><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure>
<h4 id="使用每月更新的初始化包"><a href="#使用每月更新的初始化包" class="headerlink" title="使用每月更新的初始化包"></a>使用每月更新的初始化包</h4><p>由于首次同步需要下载 24GB 数据，过程中任何网络故障都可能造成同步失败，我们强烈建议您使用初始化包进行初始化。下载 <a href="https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar" target="_blank" rel="external">https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar</a>，下载完成后记得根据 checksum.txt 的内容校验一下。由于所有代码都是从隐藏的 <code>.repo</code> 目录中 checkout 出来的，所以我们只保留了 <code>.repo</code> 目录，下载后解压 再 <code>repo sync</code> 一遍即可得到完整的目录。</p>
<p>使用方法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar # 下载初始化包</span><br><span class="line">tar xf aosp-latest.tar</span><br><span class="line">cd AOSP   # 解压得到的 AOSP 工程目录</span><br><span class="line"># 这时 ls 的话什么也看不到，因为只有一个隐藏的 .repo 目录</span><br><span class="line">repo sync # 正常同步一遍即可得到完整目录</span><br><span class="line"># 或 repo sync -l 仅checkout代码</span><br></pre></td></tr></table></figure>
<p>此后，每次只需运行 <code>repo sync</code> 即可保持同步。 <strong>我们强烈建议您保持每天同步，并尽量选择凌晨等低峰时间</strong></p>
<h3 id="3-解决repo-sync下载代码时Failed-connect错误的办法："><a href="#3-解决repo-sync下载代码时Failed-connect错误的办法：" class="headerlink" title="3 解决repo sync下载代码时Failed connect错误的办法："></a>3 解决repo sync下载代码时Failed connect错误的办法：</h3><p>下载android代码时错误提示：error: Failed connect to android.googlesource.com:443<br>解决方法：编辑/etc/hosts文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure>
<p>增加下面内容，保存</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">173.194.72.82 http://www.googlesource.com</span><br><span class="line">173.194.72.82 android.googlesource.com</span><br><span class="line">37.61.54.158 cache.pack.google.com</span><br><span class="line">173.194.74.82 gerrit.googlesource.com</span><br></pre></td></tr></table></figure>
<h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4 其他"></a>4 其他</h3><ul>
<li>初始化包大小21.4G，我的网速5-6M/s，下载时间基本一个小时左右。</li>
<li>Android7.0，aosp目录编译完之后的大小是54.6G，安装Ubuntu时要注意留够足够的空间，推荐100G+以上。</li>
</ul>
<h2 id="二、源码编译"><a href="#二、源码编译" class="headerlink" title="二、源码编译"></a>二、源码编译</h2><h3 id="1-搭建编译环境"><a href="#1-搭建编译环境" class="headerlink" title="1  搭建编译环境"></a>1  搭建编译环境</h3><ul>
<li>openJdk is needed ！我自己平时开发用的是JDK1.8，这里就要安装一下openjdk，并且更改环境变量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-7-jdk</span><br></pre></td></tr></table></figure>
<p>但是如果你是刚安装完Ubuntu，那么就可以跳过此步骤，Ubuntu自带openjdk</p>
<ul>
<li>required package</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install bison g++-multilib git gperf libxml2-utils make python-networkx zlib1g-dev:i386 zip</span><br></pre></td></tr></table></figure>
<ul>
<li>因为源码包含C 和 C++代码，gcc为必须</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc</span><br></pre></td></tr></table></figure>
<ul>
<li>Setting up ccache , 使用ccache</li>
</ul>
<p>ccache是一个编译器ccache用于C和C++。可以让构建更加快速。在源代码的根目录处，做如下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$export USE_CCACHE=1</span><br><span class="line">$export CCACHE_DIR=/&lt;path_of_your_choice&gt;/.ccache</span><br><span class="line">$prebuilts/misc/linux-x86/ccache/ccache -M 50G&lt;/path_of_your_choice&gt;</span><br></pre></td></tr></table></figure>
<p>建议的cache大小为50-100G</p>
<p>可以使用如下操作来查看使用的ccache大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$watch -n1 -d prebuilts/misc/linux-x86/ccache/ccache -s</span><br></pre></td></tr></table></figure>
<p>若使用Ice Cream Sandwich（4.0.x）或更老的版本，需要用prebuilts来代替prebuilts/misc</p>
<h3 id="2-开始编译-Building-the-System"><a href="#2-开始编译-Building-the-System" class="headerlink" title="2 开始编译 Building the System"></a>2 开始编译 Building the System</h3><ul>
<li>1.Set up environment</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source build/envsetup.sh</span><br></pre></td></tr></table></figure>
<p>or<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ . build/envsetup.sh</span><br></pre></td></tr></table></figure></p>
<ul>
<li>2.Choose a Target</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ lunch </span><br><span class="line"></span><br><span class="line">You&apos;re building on Linux</span><br><span class="line"></span><br><span class="line">Lunch menu... pick a combo:</span><br><span class="line">     1. aosp_arm-eng</span><br><span class="line">     2. aosp_arm64-eng</span><br><span class="line">     3. aosp_mips-eng</span><br><span class="line">     4. aosp_mips64-eng</span><br><span class="line">     5. aosp_x86-eng</span><br><span class="line">     6. aosp_x86_64-eng</span><br><span class="line">     7. aosp_manta-userdebug</span><br><span class="line">     8. aosp_flo-userdebug</span><br><span class="line">     9. aosp_deb-userdebug</span><br><span class="line">     10. full_fugu-userdebug</span><br><span class="line">     11. aosp_fugu-userdebug</span><br><span class="line">     12. aosp_tilapia-userdebug</span><br><span class="line">     13. aosp_grouper-userdebug</span><br><span class="line">     14. aosp_mako-userdebug</span><br><span class="line">     15. aosp_hammerhead-userdebug</span><br><span class="line">     16. aosp_flounder-userdebug</span><br><span class="line">     17. aosp_shamu-userdebug</span><br><span class="line">     18. mini_emulator_x86-userdebug</span><br><span class="line">     19. mini_emulator_arm64-userdebug</span><br><span class="line">     20. mini_emulator_x86_64-userdebug</span><br><span class="line">     21. mini_emulator_mips-userdebug</span><br><span class="line">     22. m_e_arm-userdebug</span><br><span class="line"></span><br><span class="line">Which would you like? [aosp_arm-eng]</span><br></pre></td></tr></table></figure>
<ul>
<li>3.build</li>
</ul>
<p>使用make构建，GNU make可以通过使用-jN参数来处理并行任务。此处的N，根据所用的计算机的硬件的核数来指定，一般N指定为CPU核心的1到2倍。例如我的CPU是i5-6500（CPU4个核，每个核2个线程），那么最优的构建是使用make -j8。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure>
<h3 id="3-build-successfully"><a href="#3-build-successfully" class="headerlink" title="3 build successfully"></a>3 build successfully</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### make completed successfully (01:04:27 (hh:mm:ss)) ####</span><br></pre></td></tr></table></figure>
<ul>
<li>目录结构如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">7    9月  24 00:36 android-info.txt</span><br><span class="line">62   9月  24 00:22 build_fingerprint.txt</span><br><span class="line">4.0K 9月  24 10:34 cache</span><br><span class="line">66M  9月  24 12:26 cache.img</span><br><span class="line">70K  9月  23 23:51 clean_steps.mk</span><br><span class="line">38   9月  24 00:22 current_build_config.mk</span><br><span class="line">4.0K 9月  24 10:41 data</span><br><span class="line">4.0K 9月  24 09:51 dex_bootjars</span><br><span class="line">4.0K 9月  24 01:33 gen</span><br><span class="line">1.4K 9月  24 12:25 hardware-qemu.ini</span><br><span class="line">70K  9月  24 11:00 installed-files.txt</span><br><span class="line">1.1M 9月  24 00:30 module-info.json</span><br><span class="line">4.0K 9月  24 11:00 obj</span><br><span class="line">38   9月  23 23:51 previous_build_config.mk</span><br><span class="line">1.5M 9月  24 10:40 ramdisk.img</span><br><span class="line">4.0K 9月  24 10:39 recovery</span><br><span class="line">4.0K 9月  24 10:39 root</span><br><span class="line">4.0K 9月  24 10:39 symbols</span><br><span class="line">4.0K 9月  24 10:50 system</span><br><span class="line">1.8G 9月  24 11:01 system.img</span><br><span class="line">550M 9月  24 10:58 userdata.img</span><br><span class="line">550M 9月  24 12:41 userdata-qemu.img</span><br><span class="line">~/aosp/out/target/product/generic$</span><br></pre></td></tr></table></figure>
<h3 id="4-编译中的问题解决"><a href="#4-编译中的问题解决" class="headerlink" title="4 编译中的问题解决"></a>4 编译中的问题解决</h3><ul>
<li>第一次编译，在编译到82%的时候失败，报错 ： Increase Java heap size</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">including ./tools/external/fat32lib/Android.mk ...  </span><br><span class="line">Starting build with ninja  </span><br><span class="line">ninja: Entering directory `.'  </span><br><span class="line">[  0% 1/21542] Ensure Jack server is installed and started  </span><br><span class="line">Jack server already installed in "/home/smile/.jack-server"  </span><br><span class="line">Server is already running  </span><br><span class="line">[  0% 2/21542] Building with Jack: out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/with-local/classes.dex  </span><br><span class="line">FAILED: /bin/bash out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/with-local/classes.dex.rsp  </span><br><span class="line">Java heap space  </span><br><span class="line">Try increasing heap size with java option '-Xmx<span class="tag">&lt;<span class="name">size</span>&gt;</span>'  </span><br><span class="line">Warning: This may have produced partial or corrupted output.  </span><br><span class="line">ninja: build stopped: subcommand failed.  </span><br><span class="line">build/core/ninja.mk:146: recipe for target 'ninja_wrapper' failed  </span><br><span class="line">make: *** [ninja_wrapper] Error 1  </span><br><span class="line"></span><br><span class="line">\#### make failed to build some targets (08:25 (mm:ss)) ####</span><br></pre></td></tr></table></figure>
<pre><code>stackoverflow上关于此问题的解决方法（[详见这里](http://stackoverflow.com/questions/34940793/increasing-heap-size-while-building-the-android-source-code-on-ubuntu-15-10)），在make之前进行heap size配置：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. export JACK_SERVER_VM_ARGUMENTS=&quot;-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx4096m&quot;  </span><br><span class="line">2. out/host/linux-x86/bin/jack-admin kill-server  </span><br><span class="line">3. out/host/linux-x86/bin/jack-admin start-server</span><br></pre></td></tr></table></figure>
<h2 id="三、运行"><a href="#三、运行" class="headerlink" title="三、运行"></a>三、运行</h2><h3 id="1-推送设备（真机运行）Flash-device"><a href="#1-推送设备（真机运行）Flash-device" class="headerlink" title="1  推送设备（真机运行）Flash device"></a>1  推送设备（真机运行）Flash device</h3><ul>
<li>To flash a device, you will need to use fastboot, which should be included in your path after a successful build. Place the device in fastboot mode either manually by holding the appropriate key combination at boot, or from the shell with</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb reboot bootloader</span><br></pre></td></tr></table></figure>
<ul>
<li>Once the device is in fastboot mode, run</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fastboot flashall -w</span><br></pre></td></tr></table></figure>
<ul>
<li>The -w option wipes the /data partition on the device; this is useful for your first time flashing a particular device but is otherwise unnecessary.</li>
</ul>
<h3 id="2-模拟器运行-Flash-emulator"><a href="#2-模拟器运行-Flash-emulator" class="headerlink" title="2 模拟器运行 Flash emulator"></a>2 模拟器运行 Flash emulator</h3><ul>
<li>1.build generic img </li>
</ul>
<p>lunch 1即可</p>
<ul>
<li>2.启动模拟器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">~/aosp$ emulator </span><br><span class="line"></span><br><span class="line">emulator: WARNING: system partition size adjusted to match image file (1536 MB &gt; 200 MB)</span><br><span class="line"></span><br><span class="line">emulator: WARNING: data partition size adjusted to match image file (550 MB &gt; 200 MB)</span><br><span class="line"></span><br><span class="line">emulator: WARNING: Increasing RAM size to 1GB </span><br><span class="line">Creating filesystem with parameters: </span><br><span class="line">Size: 576716800 </span><br><span class="line">Block size: 4096 </span><br><span class="line">Blocks per group: 32768 </span><br><span class="line">Inodes per group: 7040 </span><br><span class="line">Inode size: 256 </span><br><span class="line">Journal blocks: 2200 </span><br><span class="line">Label: </span><br><span class="line">Blocks: 140800 </span><br><span class="line">Block groups: 5 </span><br><span class="line">Reserved block group size: 39 </span><br><span class="line">Created filesystem with 11/35200 inodes and 4536/140800 blocks </span><br><span class="line">resize2fs 1.42.13 (17-May-2015) </span><br><span class="line">The filesystem is already 140800 (4k) blocks long. Nothing to do!</span><br><span class="line"></span><br><span class="line">Creating filesystem with parameters: </span><br><span class="line">Size: 69206016 </span><br><span class="line">Block size: 4096 </span><br><span class="line">Blocks per group: 32768 </span><br><span class="line">Inodes per group: 4224 </span><br><span class="line">Inode size: 256 </span><br><span class="line">Journal blocks: 1024 </span><br><span class="line">Label: </span><br><span class="line">Blocks: 16896 </span><br><span class="line">Block groups: 1 </span><br><span class="line">Reserved block group size: 7 </span><br><span class="line">Created filesystem with 11/4224 inodes and 1302/16896 blocks </span><br><span class="line">emulator: UpdateChecker: skipped version check</span><br></pre></td></tr></table></figure>
<h3 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3 注意事项"></a>3 注意事项</h3><ul>
<li><p>1 因为上面的环境变量配置的是临时的，所以终端关闭后,直接运行emulator是不行的,需要重新运行下/build/envsetup.sh 和lunch 选择之前编译的版本</p>
</li>
<li><p>2 安装kvm，开启硬件加速</p>
<p>无论是在Windows平台还是Linux平台，或者还是Mac OSX平台，虚拟机的硬件加速全靠这个。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install qemu-kvm</span><br></pre></td></tr></table></figure>
<p>  直接执行，完成安装即可。</p>
<p>  开启之后我们可以使用下面的指令来验证<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ egrep -c &apos;(vmx|svm)&apos; /proc/cpuinfo</span><br></pre></td></tr></table></figure></p>
<p>  执行的结果不为<code>0</code>表示开启成功(我的是<code>4</code>)。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[守夜人军团誓言]]></title>
      <url>https://sunnyxibei.github.io/2016/05/25/%E5%AE%88%E5%A4%9C%E4%BA%BA%E5%86%9B%E5%9B%A2%E8%AA%93%E8%A8%80/</url>
      <content type="html"><![CDATA[<p> “长夜将至，我从今开始守望，至死方休。我将不娶妻，不封地，不生子。我将不戴宝冠，不争荣宠。我将尽忠职守，生死于斯。我是黑暗中的利剑，长城上的守卫，抵御寒冷的烈焰，破晓时分的光线，唤醒眠者的号角，守护王国的坚盾。我将生命与荣耀献给守夜人，今夜如此，夜夜皆然。”<br><a id="more"></a></p>
<p>　　“Night gathers, and now my watch begins. It shall not end until my death. I shall take no wife, hold no lands, father no children. I shall wear no crowns and win no glory. I shall live and die at my post. I am the sword in the darkness. I am the watcher on the walls. I am the fire that burns against the cold, the light that brings the dawn, the horn that wakes the sleepers, the shield that guards the realms of men. I pledge my life and honor to the Night’s Watch, for this night and all the nights to come.”</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Retrofit 入门（二）]]></title>
      <url>https://sunnyxibei.github.io/2016/03/21/Retrofit-%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>Retrofit 入门（一）里面，简单地介绍了Get方式请求。下面说一下Post方式请求<br>Post方式请求网络，关键的地方在于请求体内容的封装<br><a id="more"></a><br>首先我们假装用post方式请求一个ip，抓到请求消息头和请求体，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">　POST/logsys/home/uploadIspeedLog!doDefault.html HTTP/1.1 </span><br><span class="line"></span><br><span class="line">　　Accept: text/plain, */* </span><br><span class="line">　　Accept-Language: zh-cn </span><br><span class="line">　　Host: 192.168.24.56</span><br><span class="line">　　Content-Type:multipart/form-data;boundary=-----------------------------7db372eb000e2</span><br><span class="line">　　User-Agent: WinHttpClient </span><br><span class="line">　　Content-Length: 3693</span><br><span class="line">　　Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">　　-------------------------------7db372eb000e2</span><br><span class="line"></span><br><span class="line">　　Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;kn.jpg&quot;</span><br><span class="line"></span><br><span class="line">　　Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line">　　(此处省略jpeg文件二进制数据...）</span><br><span class="line"></span><br><span class="line">　　-------------------------------7db372eb000e2--</span><br></pre></td></tr></table></figure>
<p>Retrofit @Path注解封装的数据，对应的是请求体中的name=”file”; filename=”kn.jpg”这一个代码片段，觉得好奇葩。</p>
<p>所以应该这么写<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Multipart</span></span><br><span class="line">    <span class="meta">@POST</span>(<span class="string">"upload"</span>)</span><br><span class="line">    <span class="function">Call&lt;UploadResult&gt; <span class="title">upload</span><span class="params">(@Part(<span class="string">"file\"; filename=\"a.jpg"</span>)</span> RequestBody file)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Multipart</span></span><br><span class="line">    <span class="meta">@POST</span>(<span class="string">"uploadMulti"</span>)</span><br><span class="line">    <span class="function">Call&lt;UploadResult&gt; <span class="title">uploadMulti</span><span class="params">(@PartMap Map&lt;String, RequestBody&gt; bodyMap)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Retrofit 入门（一）]]></title>
      <url>https://sunnyxibei.github.io/2016/03/14/Retrofit-%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="Retrofit-简介"><a href="#Retrofit-简介" class="headerlink" title="Retrofit 简介"></a>Retrofit 简介</h1><p> Square公司开发的Android平台开源的，类型安全的Http框架<br> 底层基于OkHttp，使用OkHttp进行请求,是对OkHttp的封装<br> 将java API的定义转换为interface形式<br> 使用annotation描述http请求<br> 支持配置json解析器<br><a id="more"></a></p>
<h1 id="Retrofit-使用详解"><a href="#Retrofit-使用详解" class="headerlink" title="Retrofit 使用详解"></a>Retrofit 使用详解</h1><ol>
<li><p>添加依赖</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.squareup.retrofit2:retrofit:2.1.0&apos;</span><br><span class="line">compile &apos;com.google.code.gson:gson:2.7&apos;</span><br><span class="line">compile &apos;com.squareup.retrofit2:converter-gson:2.0.2&apos;</span><br></pre></td></tr></table></figure>
<p>这里 convert-gson包是提供Json转换工厂类的，后面会说到。</p>
</li>
<li><p>定义业务逻辑接口<br>首先使用一个简单的Get请求举个栗子<br>简介里写过，Retrofit将java API的定义转换为interface形式；这样的好处是将请求网路的具体任务从业务逻辑中剥离出来，让我们可以专心地实现业务逻辑。</p>
 <figure class="highlight java"><figcaption><span>public interface TestApi &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@GET</span>(<span class="string">"test"</span>)<span class="comment">//指定该方法要请求的url</span></span><br><span class="line">    <span class="function">Call&lt;Stu&gt; <span class="title">getOrder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Retrofit底层是通过动态代理的方式，生成我们定义的接口的子类对象，并通过反射调用我们定义的方法。</p>
</li>
<li><p>创建Retrofit实例对象</p>
  <figure class="highlight java"><figcaption><span>//创建Retrofit实例对象</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">       <span class="comment">//设置服务器主机,注意，服务器主机应该以/结束，</span></span><br><span class="line">       .baseUrl(<span class="string">"http://192.168.2.103:8080/apitest/"</span>)</span><br><span class="line">	<span class="comment">//配置Gson作为json的解析器</span></span><br><span class="line">       .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">       .build();</span><br></pre></td></tr></table></figure>
<p>GsonConverterFactory，上面说过，这里要使用该工具类，必须单独依赖converter-gson包。</p>
</li>
<li><p>创建接口的实例对象</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TestApi testApi = retrofit.create(TestApi.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取业务请求对象（Call类型）</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用业务方法，得到要执行的业务请求对象</span></span><br><span class="line">	Call&lt;Stu&gt; order = testApi.getOrder();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//执行请求对象</span></span><br><span class="line">	order.enqueue(<span class="keyword">new</span> Callback&lt;Stu&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;Stu&gt; call, Response&lt;Stu&gt; response)</span> </span>&#123;</span><br><span class="line">        Stu stu = response.body();</span><br><span class="line">        text.setText(stu.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;Stu&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[沉浸式App]]></title>
      <url>https://sunnyxibei.github.io/2015/11/03/%E6%B2%89%E6%B5%B8%E5%BC%8FApp/</url>
      <content type="html"><![CDATA[<p>非全屏幕:Javacode着色状态栏<br>代码位置：com.example.systembar.CodeActivity<br>①　先写版本判断<br>②　直接调用setStatusBarColor</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    <span class="comment">//去掉titlebar-全屏模式</span></span><br><span class="line">    supportRequestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">    <span class="comment">//细节supportRequestWindowFeature一定要在setContentView之前设置</span></span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    Activity activity = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">int</span> statusColor = Color.parseColor(<span class="string">"#008000"</span>);</span><br><span class="line">    <span class="comment">//针对版本5.x以上的即LOLLIPOP以上的</span></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        Window window = activity.getWindow();</span><br><span class="line">        <span class="comment">//设置透明状态栏,这样才能让 ContentView 向上</span></span><br><span class="line">        window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">        <span class="comment">//需要设置这个 flag 才能调用 setStatusBarColor 来设置状态栏颜色</span></span><br><span class="line">        <span class="comment">// window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span></span><br><span class="line">        <span class="comment">//设置状态栏颜色</span></span><br><span class="line">        <span class="comment">// window.setStatusBarColor(statusColor);</span></span><br><span class="line">        ViewGroup mContentView = (ViewGroup) activity.findViewById(Window.ID_ANDROID_CONTENT);</span><br><span class="line">        View mChildView = mContentView.getChildAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mChildView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//注意不是设置 ContentView 的 FitsSystemWindows, 而是设置 ContentView 的第一个子 View .</span></span><br><span class="line">            <span class="comment">// 使其不为系统 View 预留空间.不预留空间的话 状态栏就会覆盖布局顶部</span></span><br><span class="line">            ViewCompat.setFitsSystemWindows(mChildView, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[手动发送SD卡就绪广播]]></title>
      <url>https://sunnyxibei.github.io/2015/10/23/%E6%89%8B%E5%8A%A8%E5%8F%91%E9%80%81SD%E5%8D%A1%E5%B0%B1%E7%BB%AA%E5%B9%BF%E6%92%AD/</url>
      <content type="html"><![CDATA[<p> 通常在我们的项目中，可能会遇到写本地文件，最常用的就是图片文件，在这之后需要通知系统重新扫描SD卡<a id="more"></a>，<br>在Android4.4之前也就是以发送一个Action为<br><code>“Intent.ACTION_MEDIA_MOUNTED”</code><br>的广播通知执行扫描。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.sendBroadcast(new </span><br><span class="line">Intent(Intent.ACTION_MEDIA_MOUNTED,Uri.parse(&quot;file://&quot; +Environment.getExternalStorageDirectory())));</span><br></pre></td></tr></table></figure>
<p>但在Android4.4中，则会抛出以下异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">W/ActivityManager(  498):</span><br><span class="line"> Permission Denial: not allowed to send broadcast </span><br><span class="line"> android.intent.action.MEDIA_MOUNTED from pid=2269, uid=20016</span><br></pre></td></tr></table></figure>
<p>那是因为Android4.4中限制了系统应用才有权限使用广播通知系统扫描SD卡。<br>解决方式：<br>使用MediaScannerConnection执行具体文件或文件夹进行扫描。（博主亲测可用，不能用博主直播吃康家沟变态辣鸡翅！）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MediaScannerConnection.scanFile(this, new String[]</span><br><span class="line">&#123;Environment.getExternalStoragePublicDirectory(Environment</span><br><span class="line">.DIRECTORY_DCIM).getPath() + &quot;/&quot; + fileName&#125;, null, null);</span><br></pre></td></tr></table></figure>
<p>MediaScannerConnection provides a way for applications to pass a newly created or downloaded media file to the media scanner service. The media scanner service will read metadata from the file and add the file to the media content provider. The MediaScannerConnectionClient provides an interface for the media scanner service to return the Uri for a newly scanned file to the client of the MediaScannerConnection class.</p>
<p>好吧，其实我用的是另外的一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent();</span><br><span class="line">intent.setAction(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);</span><br><span class="line">//这个Action其实是用来刷新指定目录的</span><br><span class="line">//但是这里我偷个懒，Uri设置为sdcard目录</span><br><span class="line">intent.setData(Uri.fromFile(Environment.getExternalStorageDirectory()));</span><br><span class="line"></span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>
<p>以上两种方式，解决的思路是一样的，—》刷新指定的文件目录。<br>但是，明显第一种更官方更专业更有逼格，也更节省资源。<br>是的，第二种方式，伪装成系统去发送欺骗广播，想一想都醉了。。。<br>涨知识了吧，骚年！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[对JNI中使用fork创建守护进程的认识]]></title>
      <url>https://sunnyxibei.github.io/2015/06/26/%E5%AF%B9JNI%E4%B8%AD%E4%BD%BF%E7%94%A8fork%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AE%A4%E8%AF%86/</url>
      <content type="html"><![CDATA[<ul>
<li>刚接触JNI，对C语言认识比较浅，所以对fork()函数纠结了一整天。查阅了一些C的资料，了解了fork的用法，恍然大悟。写一个日志出来，给同样JNI入门的哥们谋个福利。<a id="more"></a></li>
<li>先说一下我的Demo<blockquote>
<p>需求：通过JNI实现守护进程，在主进程被杀死或者卸载的时候，守护线程通过execlp()执行指定的操作。</p>
</blockquote>
</li>
</ul>
<p>##fork 基础知识</p>
<ul>
<li>fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。<ul>
<li>一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己（子进程拥有fork之前的数据 ， 但是不会执行fork 之前的函数，fork 之后，子进程和父进程同时执行后面的代码）。</li>
<li>fork()函数特性，子进程执行时返回值是0，父进程执行时返回值是子进程的pid。</li>
</ul>
</li>
</ul>
<h2 id="我的Demo"><a href="#我的Demo" class="headerlink" title="我的Demo"></a>我的Demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//了解了fork知识后，我们会知道，其实这里返回值pid已经是两个pid，</span></span><br><span class="line">    <span class="comment">//在子进程和父进程各自执行都会返回一个pid</span></span><br><span class="line"> <span class="comment">//so，根据fork函数的特性，可以根据pid的返回值来判断进程是父进程 or 子进程（守护进程），</span></span><br><span class="line"> <span class="comment">//如果是守护进程，就在守护进程中实现自己的需求。</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> pid = fork();</span><br><span class="line">FILE* f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">//大于0的时候 创建成功</span></span><br><span class="line">	LOGD(<span class="string">"pid = %d"</span>, pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">//当前进程是子进程</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		LOGD(<span class="string">"pid = %d"</span>, pid);</span><br><span class="line">		<span class="comment">//获取 父进程ID</span></span><br><span class="line">		<span class="keyword">int</span> ppid = getppid();</span><br><span class="line">		<span class="comment">//判断父进程ID 如果当前子线程的父进程ID =1 说明 要么卸载  要么被杀掉了</span></span><br><span class="line">		<span class="keyword">if</span> (ppid == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//被卸载了</span></span><br><span class="line">			f = fopen(<span class="string">"/data/data/com.example.fork"</span>, <span class="string">"r"</span>);</span><br><span class="line">			<span class="keyword">if</span> (f == NULL) &#123;</span><br><span class="line">				execlp(xxx);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//被杀掉了 </span></span><br><span class="line">				execlp(xxx);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//小于0 创建失败</span></span><br><span class="line">	LOGD(<span class="string">"pid = %d"</span>, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 常用缩略词汇]]></title>
      <url>https://sunnyxibei.github.io/2015/05/22/Android%E5%B8%B8%E7%94%A8%E7%BC%A9%E7%95%A5%E8%AF%8D%E6%B1%87/</url>
      <content type="html"><![CDATA[<ul>
<li>REST : Representational State Transfer，表述性状态传递</li>
<li>RxJava: Reactive Extensions for the JVM 响应式扩展</li>
<li>NDK: Native Develop Kits 本地开发工具包</li>
<li>JNI: Java Native Interface Java本地接口</li>
<li><a id="more"></a></li>
<li>https<br>（Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版</li>
<li>SSL<br>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。</li>
<li>ssh Secure Shell  安全外壳协议</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Baby 面试之旅（一） 面向对象的认识]]></title>
      <url>https://sunnyxibei.github.io/2015/03/23/Android-Baby-%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%97%85%EF%BC%88%E4%B8%80%EF%BC%89-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%A4%E8%AF%86/</url>
      <content type="html"><![CDATA[<p>笔试题刷完之后，终于等到了面试<br>老师问：谈谈你对面向对象的认识？<br>虎躯一紧，这么宽泛的问题，那么到底该怎么谈谈呢。<a id="more"></a></p>
<p>思考了一下，我决定从三个方面回答，什么是面向对象，面向对象的特征是什么，面向对象的原则是什么。</p>
<h2 id="什么是面向对象编程思想？"><a href="#什么是面向对象编程思想？" class="headerlink" title="什么是面向对象编程思想？"></a>什么是面向对象编程思想？</h2><p>就像算法是对问题和解决问题的抽象一样，Java中的对象，是对事物的一种抽象。而这里的事物，可以分为两种事物，一种是现实生活中或者业务中产生的实体，我们通常把他们成为Bean，根据事物的特点抽象出属性，根据事物的行为抽象出相应的方法。第二种，就是通常我们所说的万物皆对象，一个抽象的业务，我们可以把它的属性和行为抽取出来，抽象成一个类，属性就是业务处理的具体事务，方法就是执行业务的具体流程。</p>
<p>进一步，老师会提问：那么，类和对象是什么关系<br>刚才已经说过，类是对事务的抽象，而对象就是具体的事务，举个栗子，ISO9000质量管理体系，就是管理者在经营企业的过程中抽象出来的一个标准管理体系，把管理中的对象抽象成概念，把管理流程抽象成规则，这个体系就相当于面向对象中的类的概念，注意，是概念，抽象的东西。而对象，是类的一个实例，还是拿我们刚才的栗子，现在90后创业很火，我们去创业了，也想拥有ISO9000管理体系的认证，肿么办呢，我们就要按照ISO9000质量管理体系的标准，去搞一个公司，这个过程，就是把抽象的体系，实例化成一个真实的企业。类和对象，就和上面的栗子一个道理，类是对事物和业务的抽象，而对象是类的实例化。</p>
<h2 id="面向对象的三大特征？"><a href="#面向对象的三大特征？" class="headerlink" title="面向对象的三大特征？"></a>面向对象的三大特征？</h2><p>类和对象我们已经谈过了，你再说一说面向对象的三大特征吧<br>面向对象编程的三大特征（和函数式编程相比），封装，继承和多态</p>
<ul>
<li><p>封装<br>是指隐藏对象的属性和实现细节，仅外提供公共访问方式。<br>所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。 简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p>
</li>
<li><p>继承<br>所谓继承是指可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；</p>
</li>
<li><p>多态<br>谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p>
</li>
</ul>
<h2 id="面向对象的六大原则？"><a href="#面向对象的六大原则？" class="headerlink" title="面向对象的六大原则？"></a>面向对象的六大原则？</h2><p>然后老师又问了：那么，关于面向对象，你还了解什么其他的知识？<br>那么就说一说六大原则吧</p>
<ul>
<li>单一职责原则SRP(Single Responsibility Principle)<br>是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。</li>
</ul>
<ul>
<li><p>开放封闭原则OCP(Open－Close Principle)<br>一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，<br>那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。</p>
</li>
<li><p>替换原则(the Liskov Substitution Principle LSP)<br>子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，<br>也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。</p>
</li>
<li><p>依赖原则(the Dependency Inversion Principle DIP)<br>具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，<br>这个时候，B不应当直接使用A中的具体类： 而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到<br>了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。</p>
</li>
<li><p>接口分离原则(the Interface Segregation Principle ISP)<br>模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来</p>
</li>
<li><p>迪米特法则或最少知识原则 Law of Demeter or Least Knowlegde Principle（LoD or LKP）<br>这个原则首次在Demeter系统中得到正式运用，所以定义为迪米特法则。它讲的是“一个对象应当尽可能少的去了解其他对象”。也就是又一个关于如何松耦合（Loosely-Coupled）的法则。</p>
</li>
</ul>
<p>最后一点，Java入门学习时，很多教材或者教程都曾经使用过is - a 和 like - a，来描述继承和接口。但是这既正确也不正确。<br>为什么这么说呢。说不正确，因为，类和我们现实生活中的类型的概念并不一致，如果套用现实生活中的栗子，会引起异常。这里举个栗子，按照is-a的逻辑，我们定义一个基类“鸟”，然后“鸭子”是“鸟”，所以可以继承“鸟”，这时我们就会发现问题，“鸭子”并不具有基类“鸟”会飞的技能（方法），所以不能满足里氏替换原则。<br>说正确，这里的is - a，必须是抽象逻辑上的关系，子类要具备父类所有的功能。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[WebView和Js互调]]></title>
      <url>https://sunnyxibei.github.io/2014/10/28/WebView%E5%92%8CJs%E4%BA%92%E8%B0%83/</url>
      <content type="html"><![CDATA[<h2 id="WebView的基本配置"><a href="#WebView的基本配置" class="headerlink" title="WebView的基本配置"></a>WebView的基本配置</h2><a id="more"></a>
<ol>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebSettings settings = webView.getSettings();</span><br><span class="line">       settings.setJavaScriptEnabled(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>设置js为true</p>
<p>2.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">webView.setWebViewClient(<span class="keyword">new</span> WebViewClient() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">               view.loadUrl(url);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></p>
<p>复写shouldOverrideUrlLoading方法，保证url都是在WebView内打开</p>
<p>##Android 调用JS方法<br>很简单，直接使用webView.loadUrl(“javascript:javacalljs()”);</p>
<p>##JS 调用Android方法<br>注意：Android4.2以后，JS只能调用带有注解@JavaScriptInterface的Java函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webView.addJavascriptInterface(<span class="keyword">new</span> JS2JavaInterface(),<span class="string">"js2JavaInterface"</span>);</span><br></pre></td></tr></table></figure></p>
<p>使用这个方法添加一个指向JS的接口，但是实质上，参数1是一个类的对象，而非接口，参数2，是对象的别名，在JS中，使用window.js2JavaInterface.”方法名”调用该方法</p>
<p>使用这个互调可以实现什么呢？<br>比如说，新闻详情页面的WebView中有图片，在js中对图片设置点击，调用Java方法，那么我们可以在用户点击图片后开启一个新的activity，并且把图片使用ViewPager展示，提升用户体验，OK！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android项目打包的过程]]></title>
      <url>https://sunnyxibei.github.io/2014/06/28/Android%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><a id="more"></a>
<p><img src="img/android打包流程图.png" alt=""></p>
<ul>
<li>aapt: android application package tool,SDK</li>
</ul>
<h2 id="Android打包流程"><a href="#Android打包流程" class="headerlink" title="Android打包流程"></a>Android打包流程</h2><ol>
<li><p>通过aapt工具将 资源文件(res)、清单文件(AndroidManifest.xml)生成对应的R.java文件</p>
<ul>
<li><p>在项目的根目录下新建 gen目录，并且依次在gen目录下新建清单文件总包名对应的文件目录</p>
<blockquote>
<p>例如： 清单文件中包名是org.itheima.android，那么就在gen目录中新建目录结构为<br>gen/org/itheima/android</p>
</blockquote>
</li>
<li><p>通过命令生成R.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aapt package -f -m -J [R文件目录(gen)] -S [资源文件目录(res)] -I [android环境jar(android.jar)] -M [清单文件(AndroidManifest.xml)]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>通过aidl工具 将 aidl文件转化为java文件</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aidl -I[项目的源文件目录(src)] -p[aidl框架环境文件(framework.aidl)] -o[aidl输出目录(gen)] [要转换的aidl文件(your.aidl)]</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过javac工具，将<em>.java文件转化为</em>.class文件</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -encoding [编码(gbk or utf-8)] -target [版本(1.6 or 1.7)] -bootclasspath [android环境jar(android.jar)] -cp [依赖的jar(多个用;隔开;结尾)] -d [class文件输出目录] [要编译的java文件(多个用空格分开)]</span><br></pre></td></tr></table></figure>
</li>
<li><p>将libs下的jar解压到输出目录中</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar xvf [jar文件]</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过dex命令 将class文件转换为dex文件</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dx.bat --dex --output=[全路径的输出文件(classes.dex)] [全路径的class文件对应的目录]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>[全路径的class文件对应的目录] : 如果此目录依赖了其他的jar文件，需要用 <code>|</code>分隔开<br>命令: dex.bat –dex –output=输出路径 需要转换的class文件对应的路径</p>
</blockquote>
<ol>
<li><p>通过aapt工具生成资源文件包</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aapt package -f -M [清单文件(AndroidManifest.xml)] -S [资源文件目录(res)] -A [资产文件目录(assets)] -I [android环境jar(android.jar)] -F [输出的文件(resoures.ap_)]</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成未签名的apk安装文件</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apkbuilder [输出的全路径apk] -u -z [全路径打包好的资源文件包] -f [全路径dex文件]  -rf  [全路径的src目录]  -rj  [全路径的libs目录]</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成签名的apk安装文件</p>
<ul>
<li><p>生成签名文件</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkeypair -alias itheima -keyalg RSA -validity 3650 -keypass 123456 -storepass 123456 -keystore itheima.keystore</span><br></pre></td></tr></table></figure>
<blockquote>
<p> -alias : 签名的别名<br> -validity : 签名的时效<br> -keyalg : 加密的算法，一般都用RSA<br> -keystore : 生成的签名路径<br> -keypass : 密钥库的密码<br> -storepass ：密钥的密码</p>
</blockquote>
</li>
<li><p>通过签名文件给apk文件进行签名</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jarsigner -keystore 签名文件 -keypass 签名密码 -storepass 签名文件的密码 -signedjar 生成的签名文件 未签名的文件 签名的别名</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h3><ul>
<li>package 命令: 打包编译android资源<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aapt p[ackage] [-d][-f][-m][-u][-v][-x][-z][-M AndroidManifest.xml] \</span><br><span class="line">        [-0 extension [-0 extension ...]] [-g tolerance] [-j jarfile] \</span><br><span class="line">        [--min-sdk-version VAL] [--target-sdk-version VAL] \</span><br><span class="line">        [--max-sdk-version VAL] [--app-version VAL] \</span><br><span class="line">        [--app-version-name TEXT] [--custom-package VAL] \</span><br><span class="line">        [-I base-package [-I base-package ...]] \</span><br><span class="line">        [-A asset-source-dir]  [-G class-list-file] [-P public-definitions-file] \</span><br><span class="line">        [-S resource-sources [-S resource-sources ...]]         [-F apk-file] [-J R-file-dir] \</span><br><span class="line">        [raw-files-dir [raw-files-dir] ...]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>[]的参数都是可选参数。<br><strong>[-d]:  指定一个或多个设备的资源文件被添加，多个资源文件用逗号隔开</strong><br><strong>[-f]:  是否覆盖已经存在的文件（添加此参数即为覆盖，否则不覆盖）</strong><br><strong>[-m]:  打包资源的文件目录，目录地址是<code>-J</code>参数指定</strong><br><strong>[-J]:  知道R文件生成的目录</strong><br><strong>[-S]:  需要打包的资源文件目录</strong><br><strong>[-I]:  指定环境android.jar的文件目录</strong><br><strong>[-M]:  清单文件的路径</strong></p>
</blockquote>
]]></content>
    </entry>
    
  
  
</search>
