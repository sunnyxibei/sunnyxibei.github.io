<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[自定义Protocol Buffer javanano转换工厂]]></title>
      <url>https://sunnyxibei.github.io/2018/01/13/protobuf-javanano-factory/</url>
      <content type="html"><![CDATA[<p>首先介绍Protocol Buffer 和 javanao 的概念</p>
<blockquote>
<p>Protocol Buffers (a.k.a., protobuf) are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data.</p>
</blockquote>
<p>Protocol Buffer （又名，protobuf）是 Google 提供的一种语言中立，平台中立，可扩展的序列化/结构化数据的机制。</p>
<blockquote>
<p>JavaNano is a special code generator and runtime library designed specially for resource-restricted systems, like Android. It is very resource-friendly in both the amount of code and the runtime overhead. </p>
</blockquote>
<p>JavaNano是专门为资源受限系统（如Android）设计的特殊代码生成器和运行时库。 代码量和运行时开销都非常资源友好。</p>
<a id="more"></a>
<p>工作中接手的项目中，使用了Protocol Buffer javanano。查看编译生成的java类，会发现，javanano相比普通版本做了很大程度上的阉割，去掉了getter/setter方法、builder模式、Parser解析器。javanano直接解析并没有啥问题，而且很简单方便，但是，对于习惯了使用RxJava+Retrofit的我，使用工厂统一解析肯定是个硬性需求。所以问题来了，普通版本的转换工厂（com.squareup.retrofit2:converter-protobuf:2.3.0）是使用反射获取的Parser实例进行解析，javanano就使用不了，所以就有了这个自定义转换工厂。</p>
<h3 id="创建工厂"><a href="#创建工厂" class="headerlink" title="创建工厂"></a>创建工厂</h3><p>工厂类包含对ResponseBody/RequestBody两种类型的转换。</p>
<p>首先，是对ResponseBody响应消息的解析转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Converter&lt;ResponseBody, T&gt; <span class="title">responseBodyConverter</span><span class="params">(Type type, Annotation[] annotations, Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">  		<span class="comment">//判断type是否是class</span></span><br><span class="line">        <span class="keyword">if</span> (!(type <span class="keyword">instanceof</span> Class&lt;?&gt;)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; c = (Class&lt;?&gt;) type;</span><br><span class="line">  		<span class="comment">//判断type是否是MessageNano的实现类</span></span><br><span class="line">        <span class="keyword">if</span> (!MessageNano.class.isAssignableFrom(c)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  		<span class="comment">//把c传递过去，以便在convert时创建T的实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProtoNanoResponseBodyConverter&lt;&gt;(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ResponseBody对应的转换器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtoNanoResponseBodyConverter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">MessageNano</span>&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtoNanoResponseBodyConverter</span><span class="params">(Class&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(@NonNull ResponseBody value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        T msg = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//noinspection unchecked</span></span><br><span class="line">            msg = (T) c.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> msg != <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//当然，最后还是使用mergeFrom方法，将Response中的字节写入上面创建的实例msg</span></span><br><span class="line">        <span class="keyword">return</span> T.mergeFrom(msg, value.bytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是对RequestBody的转换，判断条件和ResponseBody相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Converter&lt;T, RequestBody&gt; <span class="title">requestBodyConverter</span></span><br><span class="line">            <span class="params">(Type type, Annotation[] parameterAnnotations,</span><br><span class="line">             Annotation[] methodAnnotations, Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(type <span class="keyword">instanceof</span> Class&lt;?&gt;)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!MessageNano.class.isAssignableFrom((Class&lt;?&gt;) type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProtoNanoRequestBodyConverter&lt;&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ResponseBody对应的转换器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ProtoNanoRequestBodyConverter&lt;T extends MessageNano&gt; implements Converter&lt;T, RequestBody&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static final MediaType MEDIA_TYPE = MediaType.parse(&quot;application/x-protobuf&quot;);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RequestBody convert(@NonNull T value) throws IOException &#123;</span><br><span class="line">    	//调用MessageNano的toByteArray转换成字节流</span><br><span class="line">        return RequestBody.create(MEDIA_TYPE, MessageNano.toByteArray(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用简介"><a href="#使用简介" class="headerlink" title="使用简介"></a>使用简介</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">               .baseUrl(BASE_URL)</span><br><span class="line">               .client(client.build())</span><br><span class="line">               .addConverterFactory(ProtoNanoConverterFactory.create())</span><br><span class="line">               .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br><span class="line">               .build();</span><br></pre></td></tr></table></figure>
<p>和所有工厂类的使用一样简单。</p>
<h3 id="All-in-all"><a href="#All-in-all" class="headerlink" title="All in all"></a>All in all</h3><p>自定义工厂的过程非常简单，实质上只是对<code>T.mergeFrom(msg, value.bytes())</code>和<code>MessageNano.toByteArray(value)</code>的进一步封装，统一在创建retrofit对象的使用加入转换逻辑，不必每次在回调里再行处理。</p>
<p><a href="https://github.com/sunnyxibei/ProtoNanoConverterFactory" target="_blank" rel="external">源码看这里</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android7.0源码编译运行指南]]></title>
      <url>https://sunnyxibei.github.io/2016/09/24/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<p>编译环境：Ubuntu 16.04 </p>
<p>镜像文件：清华大学AOSP镜像  Android7.0</p>
<a id="more"></a>
<h2 id="一、源码下载"><a href="#一、源码下载" class="headerlink" title="一、源码下载"></a>一、源码下载</h2><h3 id="1-镜像地址"><a href="#1-镜像地址" class="headerlink" title="1 镜像地址"></a>1 镜像地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">清华大学AOSP(Android Open Source Project)</span><br><span class="line">https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/</span><br></pre></td></tr></table></figure>
<h3 id="2-过程摘录"><a href="#2-过程摘录" class="headerlink" title="2 过程摘录"></a>2 过程摘录</h3><h4 id="下载Repo-工具"><a href="#下载Repo-工具" class="headerlink" title="下载Repo 工具"></a>下载Repo 工具</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/bin</span><br><span class="line">PATH=~/bin:$PATH</span><br><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure>
<h4 id="使用每月更新的初始化包"><a href="#使用每月更新的初始化包" class="headerlink" title="使用每月更新的初始化包"></a>使用每月更新的初始化包</h4><p>由于首次同步需要下载 24GB 数据，过程中任何网络故障都可能造成同步失败，我们强烈建议您使用初始化包进行初始化。下载 <a href="https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar" target="_blank" rel="external">https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar</a>，下载完成后记得根据 checksum.txt 的内容校验一下。由于所有代码都是从隐藏的 <code>.repo</code> 目录中 checkout 出来的，所以我们只保留了 <code>.repo</code> 目录，下载后解压 再 <code>repo sync</code> 一遍即可得到完整的目录。</p>
<p>使用方法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar # 下载初始化包</span><br><span class="line">tar xf aosp-latest.tar</span><br><span class="line">cd AOSP   # 解压得到的 AOSP 工程目录</span><br><span class="line"># 这时 ls 的话什么也看不到，因为只有一个隐藏的 .repo 目录</span><br><span class="line">repo sync # 正常同步一遍即可得到完整目录</span><br><span class="line"># 或 repo sync -l 仅checkout代码</span><br></pre></td></tr></table></figure>
<p>此后，每次只需运行 <code>repo sync</code> 即可保持同步。 <strong>我们强烈建议您保持每天同步，并尽量选择凌晨等低峰时间</strong></p>
<h3 id="3-解决repo-sync下载代码时Failed-connect错误的办法："><a href="#3-解决repo-sync下载代码时Failed-connect错误的办法：" class="headerlink" title="3 解决repo sync下载代码时Failed connect错误的办法："></a>3 解决repo sync下载代码时Failed connect错误的办法：</h3><p>下载android代码时错误提示：error: Failed connect to android.googlesource.com:443<br>解决方法：编辑/etc/hosts文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure>
<p>增加下面内容，保存</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">173.194.72.82 http://www.googlesource.com</span><br><span class="line">173.194.72.82 android.googlesource.com</span><br><span class="line">37.61.54.158 cache.pack.google.com</span><br><span class="line">173.194.74.82 gerrit.googlesource.com</span><br></pre></td></tr></table></figure>
<h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4 其他"></a>4 其他</h3><ul>
<li>初始化包大小21.4G，我的网速5-6M/s，下载时间基本一个小时左右。</li>
<li>Android7.0，aosp目录编译完之后的大小是54.6G，安装Ubuntu时要注意留够足够的空间，推荐100G+以上。</li>
</ul>
<h2 id="二、源码编译"><a href="#二、源码编译" class="headerlink" title="二、源码编译"></a>二、源码编译</h2><h3 id="1-搭建编译环境"><a href="#1-搭建编译环境" class="headerlink" title="1  搭建编译环境"></a>1  搭建编译环境</h3><ul>
<li>openJdk is needed ！我自己平时开发用的是JDK1.8，这里就要安装一下openjdk，并且更改环境变量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-7-jdk</span><br></pre></td></tr></table></figure>
<p>但是如果你是刚安装完Ubuntu，那么就可以跳过此步骤，Ubuntu自带openjdk</p>
<ul>
<li>required package</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install bison g++-multilib git gperf libxml2-utils make python-networkx zlib1g-dev:i386 zip</span><br></pre></td></tr></table></figure>
<ul>
<li>因为源码包含C 和 C++代码，gcc为必须</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc</span><br></pre></td></tr></table></figure>
<ul>
<li>Setting up ccache , 使用ccache</li>
</ul>
<p>ccache是一个编译器ccache用于C和C++。可以让构建更加快速。在源代码的根目录处，做如下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$export USE_CCACHE=1</span><br><span class="line">$export CCACHE_DIR=/&lt;path_of_your_choice&gt;/.ccache</span><br><span class="line">$prebuilts/misc/linux-x86/ccache/ccache -M 50G&lt;/path_of_your_choice&gt;</span><br></pre></td></tr></table></figure>
<p>建议的cache大小为50-100G</p>
<p>可以使用如下操作来查看使用的ccache大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$watch -n1 -d prebuilts/misc/linux-x86/ccache/ccache -s</span><br></pre></td></tr></table></figure>
<p>若使用Ice Cream Sandwich（4.0.x）或更老的版本，需要用prebuilts来代替prebuilts/misc</p>
<h3 id="2-开始编译-Building-the-System"><a href="#2-开始编译-Building-the-System" class="headerlink" title="2 开始编译 Building the System"></a>2 开始编译 Building the System</h3><ul>
<li>1.Set up environment</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source build/envsetup.sh</span><br></pre></td></tr></table></figure>
<p>or<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ . build/envsetup.sh</span><br></pre></td></tr></table></figure></p>
<ul>
<li>2.Choose a Target</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ lunch </span><br><span class="line"></span><br><span class="line">You&apos;re building on Linux</span><br><span class="line"></span><br><span class="line">Lunch menu... pick a combo:</span><br><span class="line">     1. aosp_arm-eng</span><br><span class="line">     2. aosp_arm64-eng</span><br><span class="line">     3. aosp_mips-eng</span><br><span class="line">     4. aosp_mips64-eng</span><br><span class="line">     5. aosp_x86-eng</span><br><span class="line">     6. aosp_x86_64-eng</span><br><span class="line">     7. aosp_manta-userdebug</span><br><span class="line">     8. aosp_flo-userdebug</span><br><span class="line">     9. aosp_deb-userdebug</span><br><span class="line">     10. full_fugu-userdebug</span><br><span class="line">     11. aosp_fugu-userdebug</span><br><span class="line">     12. aosp_tilapia-userdebug</span><br><span class="line">     13. aosp_grouper-userdebug</span><br><span class="line">     14. aosp_mako-userdebug</span><br><span class="line">     15. aosp_hammerhead-userdebug</span><br><span class="line">     16. aosp_flounder-userdebug</span><br><span class="line">     17. aosp_shamu-userdebug</span><br><span class="line">     18. mini_emulator_x86-userdebug</span><br><span class="line">     19. mini_emulator_arm64-userdebug</span><br><span class="line">     20. mini_emulator_x86_64-userdebug</span><br><span class="line">     21. mini_emulator_mips-userdebug</span><br><span class="line">     22. m_e_arm-userdebug</span><br><span class="line"></span><br><span class="line">Which would you like? [aosp_arm-eng]</span><br></pre></td></tr></table></figure>
<ul>
<li>3.build</li>
</ul>
<p>使用make构建，GNU make可以通过使用-jN参数来处理并行任务。此处的N，根据所用的计算机的硬件的核数来指定，一般N指定为CPU核心的1到2倍。例如我的CPU是i5-6500（CPU4个核，每个核2个线程），那么最优的构建是使用make -j8。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure>
<h3 id="3-build-successfully"><a href="#3-build-successfully" class="headerlink" title="3 build successfully"></a>3 build successfully</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### make completed successfully (01:04:27 (hh:mm:ss)) ####</span><br></pre></td></tr></table></figure>
<ul>
<li>目录结构如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">7    9月  24 00:36 android-info.txt</span><br><span class="line">62   9月  24 00:22 build_fingerprint.txt</span><br><span class="line">4.0K 9月  24 10:34 cache</span><br><span class="line">66M  9月  24 12:26 cache.img</span><br><span class="line">70K  9月  23 23:51 clean_steps.mk</span><br><span class="line">38   9月  24 00:22 current_build_config.mk</span><br><span class="line">4.0K 9月  24 10:41 data</span><br><span class="line">4.0K 9月  24 09:51 dex_bootjars</span><br><span class="line">4.0K 9月  24 01:33 gen</span><br><span class="line">1.4K 9月  24 12:25 hardware-qemu.ini</span><br><span class="line">70K  9月  24 11:00 installed-files.txt</span><br><span class="line">1.1M 9月  24 00:30 module-info.json</span><br><span class="line">4.0K 9月  24 11:00 obj</span><br><span class="line">38   9月  23 23:51 previous_build_config.mk</span><br><span class="line">1.5M 9月  24 10:40 ramdisk.img</span><br><span class="line">4.0K 9月  24 10:39 recovery</span><br><span class="line">4.0K 9月  24 10:39 root</span><br><span class="line">4.0K 9月  24 10:39 symbols</span><br><span class="line">4.0K 9月  24 10:50 system</span><br><span class="line">1.8G 9月  24 11:01 system.img</span><br><span class="line">550M 9月  24 10:58 userdata.img</span><br><span class="line">550M 9月  24 12:41 userdata-qemu.img</span><br><span class="line">~/aosp/out/target/product/generic$</span><br></pre></td></tr></table></figure>
<h3 id="4-编译中的问题解决"><a href="#4-编译中的问题解决" class="headerlink" title="4 编译中的问题解决"></a>4 编译中的问题解决</h3><ul>
<li>第一次编译，在编译到82%的时候失败，报错 ： Increase Java heap size</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">including ./tools/external/fat32lib/Android.mk ...  </span><br><span class="line">Starting build with ninja  </span><br><span class="line">ninja: Entering directory `.'  </span><br><span class="line">[  0% 1/21542] Ensure Jack server is installed and started  </span><br><span class="line">Jack server already installed in "/home/smile/.jack-server"  </span><br><span class="line">Server is already running  </span><br><span class="line">[  0% 2/21542] Building with Jack: out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/with-local/classes.dex  </span><br><span class="line">FAILED: /bin/bash out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/with-local/classes.dex.rsp  </span><br><span class="line">Java heap space  </span><br><span class="line">Try increasing heap size with java option '-Xmx<span class="tag">&lt;<span class="name">size</span>&gt;</span>'  </span><br><span class="line">Warning: This may have produced partial or corrupted output.  </span><br><span class="line">ninja: build stopped: subcommand failed.  </span><br><span class="line">build/core/ninja.mk:146: recipe for target 'ninja_wrapper' failed  </span><br><span class="line">make: *** [ninja_wrapper] Error 1  </span><br><span class="line"></span><br><span class="line">\#### make failed to build some targets (08:25 (mm:ss)) ####</span><br></pre></td></tr></table></figure>
<pre><code>stackoverflow上关于此问题的解决方法（[详见这里](http://stackoverflow.com/questions/34940793/increasing-heap-size-while-building-the-android-source-code-on-ubuntu-15-10)），在make之前进行heap size配置：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. export JACK_SERVER_VM_ARGUMENTS=&quot;-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx4096m&quot;  </span><br><span class="line">2. out/host/linux-x86/bin/jack-admin kill-server  </span><br><span class="line">3. out/host/linux-x86/bin/jack-admin start-server</span><br></pre></td></tr></table></figure>
<h2 id="三、运行"><a href="#三、运行" class="headerlink" title="三、运行"></a>三、运行</h2><h3 id="1-推送设备（真机运行）Flash-device"><a href="#1-推送设备（真机运行）Flash-device" class="headerlink" title="1  推送设备（真机运行）Flash device"></a>1  推送设备（真机运行）Flash device</h3><ul>
<li>To flash a device, you will need to use fastboot, which should be included in your path after a successful build. Place the device in fastboot mode either manually by holding the appropriate key combination at boot, or from the shell with</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb reboot bootloader</span><br></pre></td></tr></table></figure>
<ul>
<li>Once the device is in fastboot mode, run</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fastboot flashall -w</span><br></pre></td></tr></table></figure>
<ul>
<li>The -w option wipes the /data partition on the device; this is useful for your first time flashing a particular device but is otherwise unnecessary.</li>
</ul>
<h3 id="2-模拟器运行-Flash-emulator"><a href="#2-模拟器运行-Flash-emulator" class="headerlink" title="2 模拟器运行 Flash emulator"></a>2 模拟器运行 Flash emulator</h3><ul>
<li>1.build generic img </li>
</ul>
<p>lunch 1即可</p>
<ul>
<li>2.启动模拟器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">~/aosp$ emulator </span><br><span class="line"></span><br><span class="line">emulator: WARNING: system partition size adjusted to match image file (1536 MB &gt; 200 MB)</span><br><span class="line"></span><br><span class="line">emulator: WARNING: data partition size adjusted to match image file (550 MB &gt; 200 MB)</span><br><span class="line"></span><br><span class="line">emulator: WARNING: Increasing RAM size to 1GB </span><br><span class="line">Creating filesystem with parameters: </span><br><span class="line">Size: 576716800 </span><br><span class="line">Block size: 4096 </span><br><span class="line">Blocks per group: 32768 </span><br><span class="line">Inodes per group: 7040 </span><br><span class="line">Inode size: 256 </span><br><span class="line">Journal blocks: 2200 </span><br><span class="line">Label: </span><br><span class="line">Blocks: 140800 </span><br><span class="line">Block groups: 5 </span><br><span class="line">Reserved block group size: 39 </span><br><span class="line">Created filesystem with 11/35200 inodes and 4536/140800 blocks </span><br><span class="line">resize2fs 1.42.13 (17-May-2015) </span><br><span class="line">The filesystem is already 140800 (4k) blocks long. Nothing to do!</span><br><span class="line"></span><br><span class="line">Creating filesystem with parameters: </span><br><span class="line">Size: 69206016 </span><br><span class="line">Block size: 4096 </span><br><span class="line">Blocks per group: 32768 </span><br><span class="line">Inodes per group: 4224 </span><br><span class="line">Inode size: 256 </span><br><span class="line">Journal blocks: 1024 </span><br><span class="line">Label: </span><br><span class="line">Blocks: 16896 </span><br><span class="line">Block groups: 1 </span><br><span class="line">Reserved block group size: 7 </span><br><span class="line">Created filesystem with 11/4224 inodes and 1302/16896 blocks </span><br><span class="line">emulator: UpdateChecker: skipped version check</span><br></pre></td></tr></table></figure>
<h3 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3 注意事项"></a>3 注意事项</h3><ul>
<li><p>1 因为上面的环境变量配置的是临时的，所以终端关闭后,直接运行emulator是不行的,需要重新运行下/build/envsetup.sh 和lunch 选择之前编译的版本</p>
</li>
<li><p>2 安装kvm，开启硬件加速</p>
<p>无论是在Windows平台还是Linux平台，或者还是Mac OSX平台，虚拟机的硬件加速全靠这个。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install qemu-kvm</span><br></pre></td></tr></table></figure>
<p>  直接执行，完成安装即可。</p>
<p>  开启之后我们可以使用下面的指令来验证<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ egrep -c &apos;(vmx|svm)&apos; /proc/cpuinfo</span><br></pre></td></tr></table></figure></p>
<p>  执行的结果不为<code>0</code>表示开启成功(我的是<code>4</code>)。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[守夜人军团誓言]]></title>
      <url>https://sunnyxibei.github.io/2016/05/25/%E5%AE%88%E5%A4%9C%E4%BA%BA%E5%86%9B%E5%9B%A2%E8%AA%93%E8%A8%80/</url>
      <content type="html"><![CDATA[<p> “长夜将至，我从今开始守望，至死方休。我将不娶妻，不封地，不生子。我将不戴宝冠，不争荣宠。我将尽忠职守，生死于斯。我是黑暗中的利剑，长城上的守卫，抵御寒冷的烈焰，破晓时分的光线，唤醒眠者的号角，守护王国的坚盾。我将生命与荣耀献给守夜人，今夜如此，夜夜皆然。”<br><a id="more"></a></p>
<p>　　“Night gathers, and now my watch begins. It shall not end until my death. I shall take no wife, hold no lands, father no children. I shall wear no crowns and win no glory. I shall live and die at my post. I am the sword in the darkness. I am the watcher on the walls. I am the fire that burns against the cold, the light that brings the dawn, the horn that wakes the sleepers, the shield that guards the realms of men. I pledge my life and honor to the Night’s Watch, for this night and all the nights to come.”</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[对JNI中使用fork创建守护进程的认识]]></title>
      <url>https://sunnyxibei.github.io/2015/06/26/%E5%AF%B9JNI%E4%B8%AD%E4%BD%BF%E7%94%A8fork%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AE%A4%E8%AF%86/</url>
      <content type="html"><![CDATA[<ul>
<li>刚接触JNI，对C语言认识比较浅，所以对fork()函数纠结了一整天。查阅了一些C的资料，了解了fork的用法，恍然大悟。写一个日志出来，给同样JNI入门的哥们谋个福利。<a id="more"></a></li>
<li>先说一下我的Demo<blockquote>
<p>需求：通过JNI实现守护进程，在主进程被杀死或者卸载的时候，守护线程通过execlp()执行指定的操作。</p>
</blockquote>
</li>
</ul>
<p>##fork 基础知识</p>
<ul>
<li>fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。<ul>
<li>一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己（子进程拥有fork之前的数据 ， 但是不会执行fork 之前的函数，fork 之后，子进程和父进程同时执行后面的代码）。</li>
<li>fork()函数特性，子进程执行时返回值是0，父进程执行时返回值是子进程的pid。</li>
</ul>
</li>
</ul>
<h2 id="我的Demo"><a href="#我的Demo" class="headerlink" title="我的Demo"></a>我的Demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//了解了fork知识后，我们会知道，其实这里返回值pid已经是两个pid，</span></span><br><span class="line">    <span class="comment">//在子进程和父进程各自执行都会返回一个pid</span></span><br><span class="line"> <span class="comment">//so，根据fork函数的特性，可以根据pid的返回值来判断进程是父进程 or 子进程（守护进程），</span></span><br><span class="line"> <span class="comment">//如果是守护进程，就在守护进程中实现自己的需求。</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> pid = fork();</span><br><span class="line">FILE* f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">//大于0的时候 创建成功</span></span><br><span class="line">	LOGD(<span class="string">"pid = %d"</span>, pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">//当前进程是子进程</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		LOGD(<span class="string">"pid = %d"</span>, pid);</span><br><span class="line">		<span class="comment">//获取 父进程ID</span></span><br><span class="line">		<span class="keyword">int</span> ppid = getppid();</span><br><span class="line">		<span class="comment">//判断父进程ID 如果当前子线程的父进程ID =1 说明 要么卸载  要么被杀掉了</span></span><br><span class="line">		<span class="keyword">if</span> (ppid == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//被卸载了</span></span><br><span class="line">			f = fopen(<span class="string">"/data/data/com.example.fork"</span>, <span class="string">"r"</span>);</span><br><span class="line">			<span class="keyword">if</span> (f == NULL) &#123;</span><br><span class="line">				execlp(xxx);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//被杀掉了 </span></span><br><span class="line">				execlp(xxx);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//小于0 创建失败</span></span><br><span class="line">	LOGD(<span class="string">"pid = %d"</span>, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 常用缩略词汇]]></title>
      <url>https://sunnyxibei.github.io/2015/05/22/Android%E5%B8%B8%E7%94%A8%E7%BC%A9%E7%95%A5%E8%AF%8D%E6%B1%87/</url>
      <content type="html"><![CDATA[<ul>
<li>REST : Representational State Transfer，表述性状态传递</li>
<li>RxJava: Reactive Extensions for the JVM 响应式扩展</li>
<li>NDK: Native Develop Kits 本地开发工具包</li>
<li>JNI: Java Native Interface Java本地接口</li>
<li><a id="more"></a></li>
<li>https<br>（Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版</li>
<li>SSL<br>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。</li>
<li>ssh Secure Shell  安全外壳协议</li>
</ul>
]]></content>
    </entry>
    
  
  
</search>
