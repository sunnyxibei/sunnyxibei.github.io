<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[谁谓河广，一苇航之]]></title>
      <url>https://sunnyxibei.github.io/2016/10/19/%E8%B0%81%E8%B0%93%E6%B2%B3%E5%B9%BF%EF%BC%8C%E4%B8%80%E8%8B%87%E8%88%AA%E4%B9%8B/</url>
      <content type="html"><![CDATA[<p><img src="https://sunnyxibei.github.io/images/head.jpg" class="full-image"></p>
<a id="more"></a>
<p>​    十一假期，不断地观察身边的小孩子，身边的朋友，身边的同事，顿时感觉人生的局限和悲哀。人的思维和习惯，都是来自于自己可以接触到的人，在彼此的不断影响中形成自己的行为。一旦你要突破你的习惯和思考的范围，就会有一种恐慌感，前路漫漫，只能摸着石头过河。然而，好的是，在前行的道路上，或许会遇到同路人，可以共同思考和进步；坏的是，或许会遇到很多TroubleMaker，当然他们并非一定是制造了具体的Trouble，只是他们会诋毁，故意影响你的判断力，混淆是非，把你从前行的道路上拖下水。</p>
<p>​    所以，这个时候，我要更简单地前行。</p>
<p>​    当我踟躇的时候，要不断提醒自己，集中精力，瞄准自己的目标。当初刚刚开始IT生涯的时候，目标还是一些空想，但是时光荏苒，它们逐渐浮出水面。工作，学习，生活，家庭，各种角色，你想要在这个角色里成为怎样的人，尽到怎样的责任，分配怎样的时间，达到怎样的目标，正在一步一步地明晰。</p>
<p>​    工作上，自己就是想往架构师的方向发展，所以要把这个目标分解，在工作中强化自己每个方面的能力。尽量减少抱怨，提高效率。</p>
<p>​    学习上，满足自己的名校情结，同时补足自己的短板，所以在职读研的目标必须实现。</p>
<p>​    生活中，要进一步控制自己的体重，在年底的时候，要线性地减到目标体重。</p>
<p>​    家庭中，要承担起责任和义务。</p>
<p>​    谁谓河广？一苇航之。</p>
<p>​    道路虽长，我们只需一根思想的芦苇，就能一步一步地走向成长的彼岸。</p>
<p>​    一个月以后我将迎接自己孩子的降生。取名“一航”，希望孩子和我一样，在这道路上，更简单地前行。</p>
<p>​    所以，不要轻易地care别人的评论，不要轻易地参与一些毫无意义的争论（不是讨论），要时刻记住自己的目标。前行的道路，很简单，想要什么，就要付出什么。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android7.0源码编译运行指南]]></title>
      <url>https://sunnyxibei.github.io/2016/09/24/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<p>编译环境：Ubuntu 16.04 </p>
<p>镜像文件：清华大学AOSP镜像  Android7.0</p>
<a id="more"></a>
<h2 id="一、源码下载"><a href="#一、源码下载" class="headerlink" title="一、源码下载"></a>一、源码下载</h2><h3 id="1-镜像地址"><a href="#1-镜像地址" class="headerlink" title="1 镜像地址"></a>1 镜像地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">清华大学AOSP(Android Open Source Project)</span><br><span class="line">https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/</span><br></pre></td></tr></table></figure>
<h3 id="2-过程摘录"><a href="#2-过程摘录" class="headerlink" title="2 过程摘录"></a>2 过程摘录</h3><h4 id="下载Repo-工具"><a href="#下载Repo-工具" class="headerlink" title="下载Repo 工具"></a>下载Repo 工具</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/bin</span><br><span class="line">PATH=~/bin:$PATH</span><br><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure>
<h4 id="使用每月更新的初始化包"><a href="#使用每月更新的初始化包" class="headerlink" title="使用每月更新的初始化包"></a>使用每月更新的初始化包</h4><p>由于首次同步需要下载 24GB 数据，过程中任何网络故障都可能造成同步失败，我们强烈建议您使用初始化包进行初始化。下载 <a href="https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar" target="_blank" rel="external">https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar</a>，下载完成后记得根据 checksum.txt 的内容校验一下。由于所有代码都是从隐藏的 <code>.repo</code> 目录中 checkout 出来的，所以我们只保留了 <code>.repo</code> 目录，下载后解压 再 <code>repo sync</code> 一遍即可得到完整的目录。</p>
<p>使用方法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar # 下载初始化包</span><br><span class="line">tar xf aosp-latest.tar</span><br><span class="line">cd AOSP   # 解压得到的 AOSP 工程目录</span><br><span class="line"># 这时 ls 的话什么也看不到，因为只有一个隐藏的 .repo 目录</span><br><span class="line">repo sync # 正常同步一遍即可得到完整目录</span><br><span class="line"># 或 repo sync -l 仅checkout代码</span><br></pre></td></tr></table></figure>
<p>此后，每次只需运行 <code>repo sync</code> 即可保持同步。 <strong>我们强烈建议您保持每天同步，并尽量选择凌晨等低峰时间</strong></p>
<h3 id="3-解决repo-sync下载代码时Failed-connect错误的办法："><a href="#3-解决repo-sync下载代码时Failed-connect错误的办法：" class="headerlink" title="3 解决repo sync下载代码时Failed connect错误的办法："></a>3 解决repo sync下载代码时Failed connect错误的办法：</h3><p>下载android代码时错误提示：error: Failed connect to android.googlesource.com:443<br>解决方法：编辑/etc/hosts文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure>
<p>增加下面内容，保存</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">173.194.72.82 http://www.googlesource.com</span><br><span class="line">173.194.72.82 android.googlesource.com</span><br><span class="line">37.61.54.158 cache.pack.google.com</span><br><span class="line">173.194.74.82 gerrit.googlesource.com</span><br></pre></td></tr></table></figure>
<h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4 其他"></a>4 其他</h3><ul>
<li>初始化包大小21.4G，我的网速5-6M/s，下载时间基本一个小时左右。</li>
<li>Android7.0，aosp目录编译完之后的大小是54.6G，安装Ubuntu时要注意留够足够的空间，推荐100G+以上。</li>
</ul>
<h2 id="二、源码编译"><a href="#二、源码编译" class="headerlink" title="二、源码编译"></a>二、源码编译</h2><h3 id="1-搭建编译环境"><a href="#1-搭建编译环境" class="headerlink" title="1  搭建编译环境"></a>1  搭建编译环境</h3><ul>
<li>openJdk is needed ！我自己平时开发用的是JDK1.8，这里就要安装一下openjdk，并且更改环境变量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-7-jdk</span><br></pre></td></tr></table></figure>
<p>但是如果你是刚安装完Ubuntu，那么就可以跳过此步骤，Ubuntu自带openjdk</p>
<ul>
<li>required package</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install bison g++-multilib git gperf libxml2-utils make python-networkx zlib1g-dev:i386 zip</span><br></pre></td></tr></table></figure>
<ul>
<li>因为源码包含C 和 C++代码，gcc为必须</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc</span><br></pre></td></tr></table></figure>
<ul>
<li>Setting up ccache , 使用ccache</li>
</ul>
<p>ccache是一个编译器ccache用于C和C++。可以让构建更加快速。在源代码的根目录处，做如下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$export USE_CCACHE=1</span><br><span class="line">$export CCACHE_DIR=/&lt;path_of_your_choice&gt;/.ccache</span><br><span class="line">$prebuilts/misc/linux-x86/ccache/ccache -M 50G&lt;/path_of_your_choice&gt;</span><br></pre></td></tr></table></figure>
<p>建议的cache大小为50-100G</p>
<p>可以使用如下操作来查看使用的ccache大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$watch -n1 -d prebuilts/misc/linux-x86/ccache/ccache -s</span><br></pre></td></tr></table></figure>
<p>若使用Ice Cream Sandwich（4.0.x）或更老的版本，需要用prebuilts来代替prebuilts/misc</p>
<h3 id="2-开始编译-Building-the-System"><a href="#2-开始编译-Building-the-System" class="headerlink" title="2 开始编译 Building the System"></a>2 开始编译 Building the System</h3><ul>
<li>1.Set up environment</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source build/envsetup.sh</span><br></pre></td></tr></table></figure>
<p>or<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ . build/envsetup.sh</span><br></pre></td></tr></table></figure></p>
<ul>
<li>2.Choose a Target</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ lunch </span><br><span class="line"></span><br><span class="line">You&apos;re building on Linux</span><br><span class="line"></span><br><span class="line">Lunch menu... pick a combo:</span><br><span class="line">     1. aosp_arm-eng</span><br><span class="line">     2. aosp_arm64-eng</span><br><span class="line">     3. aosp_mips-eng</span><br><span class="line">     4. aosp_mips64-eng</span><br><span class="line">     5. aosp_x86-eng</span><br><span class="line">     6. aosp_x86_64-eng</span><br><span class="line">     7. aosp_manta-userdebug</span><br><span class="line">     8. aosp_flo-userdebug</span><br><span class="line">     9. aosp_deb-userdebug</span><br><span class="line">     10. full_fugu-userdebug</span><br><span class="line">     11. aosp_fugu-userdebug</span><br><span class="line">     12. aosp_tilapia-userdebug</span><br><span class="line">     13. aosp_grouper-userdebug</span><br><span class="line">     14. aosp_mako-userdebug</span><br><span class="line">     15. aosp_hammerhead-userdebug</span><br><span class="line">     16. aosp_flounder-userdebug</span><br><span class="line">     17. aosp_shamu-userdebug</span><br><span class="line">     18. mini_emulator_x86-userdebug</span><br><span class="line">     19. mini_emulator_arm64-userdebug</span><br><span class="line">     20. mini_emulator_x86_64-userdebug</span><br><span class="line">     21. mini_emulator_mips-userdebug</span><br><span class="line">     22. m_e_arm-userdebug</span><br><span class="line"></span><br><span class="line">Which would you like? [aosp_arm-eng]</span><br></pre></td></tr></table></figure>
<ul>
<li>3.build</li>
</ul>
<p>使用make构建，GNU make可以通过使用-jN参数来处理并行任务。此处的N，根据所用的计算机的硬件的核数来指定，一般N指定为CPU核心的1到2倍。例如我的CPU是i5-6500（CPU4个核，每个核2个线程），那么最优的构建是使用make -j8。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure>
<h3 id="3-build-successfully"><a href="#3-build-successfully" class="headerlink" title="3 build successfully"></a>3 build successfully</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### make completed successfully (01:04:27 (hh:mm:ss)) ####</span><br></pre></td></tr></table></figure>
<ul>
<li>目录结构如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">7    9月  24 00:36 android-info.txt</span><br><span class="line">62   9月  24 00:22 build_fingerprint.txt</span><br><span class="line">4.0K 9月  24 10:34 cache</span><br><span class="line">66M  9月  24 12:26 cache.img</span><br><span class="line">70K  9月  23 23:51 clean_steps.mk</span><br><span class="line">38   9月  24 00:22 current_build_config.mk</span><br><span class="line">4.0K 9月  24 10:41 data</span><br><span class="line">4.0K 9月  24 09:51 dex_bootjars</span><br><span class="line">4.0K 9月  24 01:33 gen</span><br><span class="line">1.4K 9月  24 12:25 hardware-qemu.ini</span><br><span class="line">70K  9月  24 11:00 installed-files.txt</span><br><span class="line">1.1M 9月  24 00:30 module-info.json</span><br><span class="line">4.0K 9月  24 11:00 obj</span><br><span class="line">38   9月  23 23:51 previous_build_config.mk</span><br><span class="line">1.5M 9月  24 10:40 ramdisk.img</span><br><span class="line">4.0K 9月  24 10:39 recovery</span><br><span class="line">4.0K 9月  24 10:39 root</span><br><span class="line">4.0K 9月  24 10:39 symbols</span><br><span class="line">4.0K 9月  24 10:50 system</span><br><span class="line">1.8G 9月  24 11:01 system.img</span><br><span class="line">550M 9月  24 10:58 userdata.img</span><br><span class="line">550M 9月  24 12:41 userdata-qemu.img</span><br><span class="line">~/aosp/out/target/product/generic$</span><br></pre></td></tr></table></figure>
<h3 id="4-编译中的问题解决"><a href="#4-编译中的问题解决" class="headerlink" title="4 编译中的问题解决"></a>4 编译中的问题解决</h3><ul>
<li>第一次编译，在编译到82%的时候失败，报错 ： Increase Java heap size</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">including ./tools/external/fat32lib/Android.mk ...  </span><br><span class="line">Starting build with ninja  </span><br><span class="line">ninja: Entering directory `.'  </span><br><span class="line">[  0% 1/21542] Ensure Jack server is installed and started  </span><br><span class="line">Jack server already installed in "/home/smile/.jack-server"  </span><br><span class="line">Server is already running  </span><br><span class="line">[  0% 2/21542] Building with Jack: out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/with-local/classes.dex  </span><br><span class="line">FAILED: /bin/bash out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/with-local/classes.dex.rsp  </span><br><span class="line">Java heap space  </span><br><span class="line">Try increasing heap size with java option '-Xmx<span class="tag">&lt;<span class="name">size</span>&gt;</span>'  </span><br><span class="line">Warning: This may have produced partial or corrupted output.  </span><br><span class="line">ninja: build stopped: subcommand failed.  </span><br><span class="line">build/core/ninja.mk:146: recipe for target 'ninja_wrapper' failed  </span><br><span class="line">make: *** [ninja_wrapper] Error 1  </span><br><span class="line"></span><br><span class="line">\#### make failed to build some targets (08:25 (mm:ss)) ####</span><br></pre></td></tr></table></figure>
<pre><code>stackoverflow上关于此问题的解决方法（[详见这里](http://stackoverflow.com/questions/34940793/increasing-heap-size-while-building-the-android-source-code-on-ubuntu-15-10)），在make之前进行heap size配置：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. export JACK_SERVER_VM_ARGUMENTS=&quot;-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx4096m&quot;  </span><br><span class="line">2. out/host/linux-x86/bin/jack-admin kill-server  </span><br><span class="line">3. out/host/linux-x86/bin/jack-admin start-server</span><br></pre></td></tr></table></figure>
<h2 id="三、运行"><a href="#三、运行" class="headerlink" title="三、运行"></a>三、运行</h2><h3 id="1-推送设备（真机运行）Flash-device"><a href="#1-推送设备（真机运行）Flash-device" class="headerlink" title="1  推送设备（真机运行）Flash device"></a>1  推送设备（真机运行）Flash device</h3><ul>
<li>To flash a device, you will need to use fastboot, which should be included in your path after a successful build. Place the device in fastboot mode either manually by holding the appropriate key combination at boot, or from the shell with</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb reboot bootloader</span><br></pre></td></tr></table></figure>
<ul>
<li>Once the device is in fastboot mode, run</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fastboot flashall -w</span><br></pre></td></tr></table></figure>
<ul>
<li>The -w option wipes the /data partition on the device; this is useful for your first time flashing a particular device but is otherwise unnecessary.</li>
</ul>
<h3 id="2-模拟器运行-Flash-emulator"><a href="#2-模拟器运行-Flash-emulator" class="headerlink" title="2 模拟器运行 Flash emulator"></a>2 模拟器运行 Flash emulator</h3><ul>
<li>1.build generic img </li>
</ul>
<p>lunch 1即可</p>
<ul>
<li>2.启动模拟器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">~/aosp$ emulator </span><br><span class="line"></span><br><span class="line">emulator: WARNING: system partition size adjusted to match image file (1536 MB &gt; 200 MB)</span><br><span class="line"></span><br><span class="line">emulator: WARNING: data partition size adjusted to match image file (550 MB &gt; 200 MB)</span><br><span class="line"></span><br><span class="line">emulator: WARNING: Increasing RAM size to 1GB </span><br><span class="line">Creating filesystem with parameters: </span><br><span class="line">Size: 576716800 </span><br><span class="line">Block size: 4096 </span><br><span class="line">Blocks per group: 32768 </span><br><span class="line">Inodes per group: 7040 </span><br><span class="line">Inode size: 256 </span><br><span class="line">Journal blocks: 2200 </span><br><span class="line">Label: </span><br><span class="line">Blocks: 140800 </span><br><span class="line">Block groups: 5 </span><br><span class="line">Reserved block group size: 39 </span><br><span class="line">Created filesystem with 11/35200 inodes and 4536/140800 blocks </span><br><span class="line">resize2fs 1.42.13 (17-May-2015) </span><br><span class="line">The filesystem is already 140800 (4k) blocks long. Nothing to do!</span><br><span class="line"></span><br><span class="line">Creating filesystem with parameters: </span><br><span class="line">Size: 69206016 </span><br><span class="line">Block size: 4096 </span><br><span class="line">Blocks per group: 32768 </span><br><span class="line">Inodes per group: 4224 </span><br><span class="line">Inode size: 256 </span><br><span class="line">Journal blocks: 1024 </span><br><span class="line">Label: </span><br><span class="line">Blocks: 16896 </span><br><span class="line">Block groups: 1 </span><br><span class="line">Reserved block group size: 7 </span><br><span class="line">Created filesystem with 11/4224 inodes and 1302/16896 blocks </span><br><span class="line">emulator: UpdateChecker: skipped version check</span><br></pre></td></tr></table></figure>
<h3 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3 注意事项"></a>3 注意事项</h3><ul>
<li><p>1 因为上面的环境变量配置的是临时的，所以终端关闭后,直接运行emulator是不行的,需要重新运行下/build/envsetup.sh 和lunch 选择之前编译的版本</p>
</li>
<li><p>2 安装kvm，开启硬件加速</p>
<p>无论是在Windows平台还是Linux平台，或者还是Mac OSX平台，虚拟机的硬件加速全靠这个。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install qemu-kvm</span><br></pre></td></tr></table></figure>
<p>  直接执行，完成安装即可。</p>
<p>  开启之后我们可以使用下面的指令来验证<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ egrep -c &apos;(vmx|svm)&apos; /proc/cpuinfo</span><br></pre></td></tr></table></figure></p>
<p>  执行的结果不为<code>0</code>表示开启成功(我的是<code>4</code>)。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[守夜人军团誓言]]></title>
      <url>https://sunnyxibei.github.io/2016/05/25/%E5%AE%88%E5%A4%9C%E4%BA%BA%E5%86%9B%E5%9B%A2%E8%AA%93%E8%A8%80/</url>
      <content type="html"><![CDATA[<p> “长夜将至，我从今开始守望，至死方休。我将不娶妻，不封地，不生子。我将不戴宝冠，不争荣宠。我将尽忠职守，生死于斯。我是黑暗中的利剑，长城上的守卫，抵御寒冷的烈焰，破晓时分的光线，唤醒眠者的号角，守护王国的坚盾。我将生命与荣耀献给守夜人，今夜如此，夜夜皆然。”<br><a id="more"></a></p>
<p>　　“Night gathers, and now my watch begins. It shall not end until my death. I shall take no wife, hold no lands, father no children. I shall wear no crowns and win no glory. I shall live and die at my post. I am the sword in the darkness. I am the watcher on the walls. I am the fire that burns against the cold, the light that brings the dawn, the horn that wakes the sleepers, the shield that guards the realms of men. I pledge my life and honor to the Night’s Watch, for this night and all the nights to come.”</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[对JNI中使用fork创建守护进程的认识]]></title>
      <url>https://sunnyxibei.github.io/2015/06/26/%E5%AF%B9JNI%E4%B8%AD%E4%BD%BF%E7%94%A8fork%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AE%A4%E8%AF%86/</url>
      <content type="html"><![CDATA[<ul>
<li>刚接触JNI，对C语言认识比较浅，所以对fork()函数纠结了一整天。查阅了一些C的资料，了解了fork的用法，恍然大悟。写一个日志出来，给同样JNI入门的哥们谋个福利。<a id="more"></a></li>
<li>先说一下我的Demo<blockquote>
<p>需求：通过JNI实现守护进程，在主进程被杀死或者卸载的时候，守护线程通过execlp()执行指定的操作。</p>
</blockquote>
</li>
</ul>
<p>##fork 基础知识</p>
<ul>
<li>fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。<ul>
<li>一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己（子进程拥有fork之前的数据 ， 但是不会执行fork 之前的函数，fork 之后，子进程和父进程同时执行后面的代码）。</li>
<li>fork()函数特性，子进程执行时返回值是0，父进程执行时返回值是子进程的pid。</li>
</ul>
</li>
</ul>
<h2 id="我的Demo"><a href="#我的Demo" class="headerlink" title="我的Demo"></a>我的Demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//了解了fork知识后，我们会知道，其实这里返回值pid已经是两个pid，</span></span><br><span class="line">    <span class="comment">//在子进程和父进程各自执行都会返回一个pid</span></span><br><span class="line"> <span class="comment">//so，根据fork函数的特性，可以根据pid的返回值来判断进程是父进程 or 子进程（守护进程），</span></span><br><span class="line"> <span class="comment">//如果是守护进程，就在守护进程中实现自己的需求。</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> pid = fork();</span><br><span class="line">FILE* f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">//大于0的时候 创建成功</span></span><br><span class="line">	LOGD(<span class="string">"pid = %d"</span>, pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">//当前进程是子进程</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		LOGD(<span class="string">"pid = %d"</span>, pid);</span><br><span class="line">		<span class="comment">//获取 父进程ID</span></span><br><span class="line">		<span class="keyword">int</span> ppid = getppid();</span><br><span class="line">		<span class="comment">//判断父进程ID 如果当前子线程的父进程ID =1 说明 要么卸载  要么被杀掉了</span></span><br><span class="line">		<span class="keyword">if</span> (ppid == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//被卸载了</span></span><br><span class="line">			f = fopen(<span class="string">"/data/data/com.example.fork"</span>, <span class="string">"r"</span>);</span><br><span class="line">			<span class="keyword">if</span> (f == NULL) &#123;</span><br><span class="line">				execlp(xxx);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//被杀掉了 </span></span><br><span class="line">				execlp(xxx);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//小于0 创建失败</span></span><br><span class="line">	LOGD(<span class="string">"pid = %d"</span>, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 常用缩略词汇]]></title>
      <url>https://sunnyxibei.github.io/2015/05/22/Android%E5%B8%B8%E7%94%A8%E7%BC%A9%E7%95%A5%E8%AF%8D%E6%B1%87/</url>
      <content type="html"><![CDATA[<ul>
<li>REST : Representational State Transfer，表述性状态传递</li>
<li>RxJava: Reactive Extensions for the JVM 响应式扩展</li>
<li>NDK: Native Develop Kits 本地开发工具包</li>
<li>JNI: Java Native Interface Java本地接口</li>
<li><a id="more"></a></li>
<li>https<br>（Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版</li>
<li>SSL<br>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。</li>
<li>ssh Secure Shell  安全外壳协议</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Baby 面试之旅（一） 面向对象的认识]]></title>
      <url>https://sunnyxibei.github.io/2015/03/23/Android-Baby-%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%97%85%EF%BC%88%E4%B8%80%EF%BC%89-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%A4%E8%AF%86/</url>
      <content type="html"><![CDATA[<p>笔试题刷完之后，终于等到了面试<br>老师问：谈谈你对面向对象的认识？<br>虎躯一紧，这么宽泛的问题，那么到底该怎么谈谈呢。<a id="more"></a></p>
<p>思考了一下，我决定从三个方面回答，什么是面向对象，面向对象的特征是什么，面向对象的原则是什么。</p>
<h2 id="什么是面向对象编程思想？"><a href="#什么是面向对象编程思想？" class="headerlink" title="什么是面向对象编程思想？"></a>什么是面向对象编程思想？</h2><p>就像算法是对问题和解决问题的抽象一样，Java中的对象，是对事物的一种抽象。而这里的事物，可以分为两种事物，一种是现实生活中或者业务中产生的实体，我们通常把他们成为Bean，根据事物的特点抽象出属性，根据事物的行为抽象出相应的方法。第二种，就是通常我们所说的万物皆对象，一个抽象的业务，我们可以把它的属性和行为抽取出来，抽象成一个类，属性就是业务处理的具体事务，方法就是执行业务的具体流程。</p>
<p>进一步，老师会提问：那么，类和对象是什么关系<br>刚才已经说过，类是对事务的抽象，而对象就是具体的事务，举个栗子，ISO9000质量管理体系，就是管理者在经营企业的过程中抽象出来的一个标准管理体系，把管理中的对象抽象成概念，把管理流程抽象成规则，这个体系就相当于面向对象中的类的概念，注意，是概念，抽象的东西。而对象，是类的一个实例，还是拿我们刚才的栗子，现在90后创业很火，我们去创业了，也想拥有ISO9000管理体系的认证，肿么办呢，我们就要按照ISO9000质量管理体系的标准，去搞一个公司，这个过程，就是把抽象的体系，实例化成一个真实的企业。类和对象，就和上面的栗子一个道理，类是对事物和业务的抽象，而对象是类的实例化。</p>
<h2 id="面向对象的三大特征？"><a href="#面向对象的三大特征？" class="headerlink" title="面向对象的三大特征？"></a>面向对象的三大特征？</h2><p>类和对象我们已经谈过了，你再说一说面向对象的三大特征吧<br>面向对象编程的三大特征（和函数式编程相比），封装，继承和多态</p>
<ul>
<li><p>封装<br>是指隐藏对象的属性和实现细节，仅外提供公共访问方式。<br>所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。 简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p>
</li>
<li><p>继承<br>所谓继承是指可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；</p>
</li>
<li><p>多态<br>谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p>
</li>
</ul>
<h2 id="面向对象的六大原则？"><a href="#面向对象的六大原则？" class="headerlink" title="面向对象的六大原则？"></a>面向对象的六大原则？</h2><p>然后老师又问了：那么，关于面向对象，你还了解什么其他的知识？<br>那么就说一说六大原则吧</p>
<ul>
<li>单一职责原则SRP(Single Responsibility Principle)<br>是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。</li>
</ul>
<ul>
<li><p>开放封闭原则OCP(Open－Close Principle)<br>一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，<br>那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。</p>
</li>
<li><p>替换原则(the Liskov Substitution Principle LSP)<br>子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，<br>也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。</p>
</li>
<li><p>依赖原则(the Dependency Inversion Principle DIP)<br>具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，<br>这个时候，B不应当直接使用A中的具体类： 而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到<br>了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。</p>
</li>
<li><p>接口分离原则(the Interface Segregation Principle ISP)<br>模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来</p>
</li>
<li><p>迪米特法则或最少知识原则 Law of Demeter or Least Knowlegde Principle（LoD or LKP）<br>这个原则首次在Demeter系统中得到正式运用，所以定义为迪米特法则。它讲的是“一个对象应当尽可能少的去了解其他对象”。也就是又一个关于如何松耦合（Loosely-Coupled）的法则。</p>
</li>
</ul>
<p>最后一点，Java入门学习时，很多教材或者教程都曾经使用过is - a 和 like - a，来描述继承和接口。但是这既正确也不正确。<br>为什么这么说呢。说不正确，因为，类和我们现实生活中的类型的概念并不一致，如果套用现实生活中的栗子，会引起异常。这里举个栗子，按照is-a的逻辑，我们定义一个基类“鸟”，然后“鸭子”是“鸟”，所以可以继承“鸟”，这时我们就会发现问题，“鸭子”并不具有基类“鸟”会飞的技能（方法），所以不能满足里氏替换原则。<br>说正确，这里的is - a，必须是抽象逻辑上的关系，子类要具备父类所有的功能。</p>
]]></content>
    </entry>
    
  
  
</search>
